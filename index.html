<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¼˜åŒ–ç‰ˆæœ¬åœ°ç¦»çº¿è½¦ç‰ŒOCRè¯†åˆ«ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .upload-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border: 2px dashed #dee2e6;
        }
        
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }
        
        .upload-area:hover {
            background: #e6f7ff;
            border-color: #1890ff;
        }
        
        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 15px;
        }
        
        .upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        
        .upload-btn:hover {
            background: #5a6fd8;
        }
        
        .image-preview {
            position: relative;
            margin-top: 20px;
            display: none;
        }
        
        .preview-img {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        
        .highlight {
            position: absolute;
            border: 3px solid #ffeb3b;
            box-shadow: 0 0 20px rgba(255, 235, 59, 0.8);
            z-index: 100;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.6); }
            70% { box-shadow: 0 0 0 15px rgba(255, 235, 59, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0); }
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .process-btn, .reset-btn, .preprocess-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }
        
        .process-btn {
            background: #4caf50;
            color: white;
        }
        
        .process-btn:hover:not(:disabled) {
            background: #45a049;
        }
        
        .process-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .preprocess-btn {
            background: #ff9800;
            color: white;
        }
        
        .preprocess-btn:hover:not(:disabled) {
            background: #e68900;
        }
        
        .reset-btn {
            background: #f44336;
            color: white;
        }
        
        .reset-btn:hover {
            background: #da190b;
        }
        
        .results-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
        }
        
        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: bold;
            color: #333;
        }
        
        select, input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        
        .search-input {
            flex: 1;
            min-width: 200px;
        }
        
        .status-message {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .plates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .plate-item {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .plate-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-color: #667eea;
        }
        
        .plate-item.selected {
            border-color: #667eea;
            background: #e6f7ff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        .plate-number {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .plate-score {
            font-size: 0.9em;
            color: #666;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .plate-tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            color: white;
            text-align: center;
            margin-top: 5px;
        }
        
        .tag-baozi { background: #ff6b6b; }
        .tag-shuanglian { background: #4ecdc4; }
        .tag-wanggeng { background: #45b7d1; }
        .tag-normal { background: #9b59b6; }
        
        .wanggeng-note {
            font-size: 0.8em;
            color: #e74c3c;
            margin-top: 5px;
            padding: 4px;
            background: #fdf2f2;
            border-radius: 3px;
            text-align: center;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-results {
            text-align: center;
            color: #999;
            padding: 40px;
            grid-column: 1 / -1;
        }
        
        .preprocessing-options {
            margin-top: 15px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            display: none;
        }
        
        .preprocessing-options.show {
            display: block;
        }
        
        .option-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .option-group label {
            font-weight: normal;
        }
        
        footer {
            background: #343a40;
            color: white;
            text-align: center;
            padding: 20px;
            margin-top: 20px;
        }
        
        .confidence-score {
            font-size: 0.8em;
            color: #28a745;
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸš— ä¼˜åŒ–ç‰ˆæœ¬åœ°ç¦»çº¿è½¦ç‰ŒOCRè¯†åˆ«ç³»ç»Ÿ</h1>
            <p class="subtitle">åŸºäºTesseract.js + å›¾åƒé¢„å¤„ç†çš„é«˜ç²¾åº¦è½¦ç‰Œè¯†åˆ«</p>
        </header>
        
        <div class="main-content">
            <div class="upload-section">
                <h2>ğŸ“¤ ä¸Šä¼ è½¦ç‰Œå›¾ç‰‡</h2>
                <p>è¯·ä¸Šä¼ ä¸€å¼ åŒ…å«è½¦ç‰Œå·çš„å›¾ç‰‡ï¼ˆæ”¯æŒç¦»çº¿OCRè¯†åˆ«ï¼‰</p>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</div>
                    <button class="upload-btn" id="realUploadBtn">é€‰æ‹©å›¾ç‰‡</button>
                    <input type="file" id="fileInput" accept="image/*" style="display: none;">
                </div>
                
                <div class="image-preview" id="imagePreview">
                    <img id="previewImg" class="preview-img" src="" alt="é¢„è§ˆå›¾ç‰‡">
                </div>
                
                <div class="controls">
                    <button class="preprocess-btn" id="preprocessBtn" disabled>ğŸ”§ é¢„å¤„ç†é€‰é¡¹</button>
                    <button class="process-btn" id="processBtn" disabled>ğŸ” å¼€å§‹è¯†åˆ«</button>
                    <button class="reset-btn" id="resetBtn">ğŸ”„ é‡ç½®</button>
                </div>
                
                <div class="preprocessing-options" id="preprocessingOptions">
                    <h3>å›¾åƒé¢„å¤„ç†é€‰é¡¹</h3>
                    <div class="option-group">
                        <label>
                            <input type="checkbox" id="grayscaleCheck"> ç°åº¦åŒ–
                        </label>
                        <label>
                            <input type="checkbox" id="contrastCheck" checked> å¢å¼ºå¯¹æ¯”åº¦
                        </label>
                        <label>
                            <input type="checkbox" id="denoiseCheck" checked> å»å™ª
                        </label>
                    </div>
                    <div class="option-group">
                        <label>
                            <input type="checkbox" id="thresholdCheck"> äºŒå€¼åŒ–
                        </label>
                        <label>
                            äºŒå€¼åŒ–é˜ˆå€¼:
                            <input type="number" id="thresholdValue" value="128" min="0" max="255" step="1">
                        </label>
                    </div>
                    <div class="option-group">
                        <label>
                            ç¼©æ”¾æ¯”ä¾‹:
                            <select id="scaleSelect">
                                <option value="1">åŸå§‹å¤§å°</option>
                                <option value="1.5" selected>1.5å€</option>
                                <option value="2">2å€</option>
                                <option value="2.5">2.5å€</option>
                                <option value="3">3å€</option>
                            </select>
                        </label>
                        <label>
                            æ—‹è½¬è§’åº¦:
                            <select id="rotateSelect">
                                <option value="0">0Â°</option>
                                <option value="90">90Â°</option>
                                <option value="180">180Â°</option>
                                <option value="270">270Â°</option>
                            </select>
                        </label>
                    </div>
                </div>
                
                <div class="status-message" id="statusMessage"></div>
            </div>
            
            <div class="results-section">
                <h2>ğŸ“Š è¯†åˆ«ç»“æœ</h2>
                
                <div class="filters">
                    <div class="filter-group">
                        <label for="filterSelect">ç­›é€‰:</label>
                        <select id="filterSelect">
                            <option value="">å…¨éƒ¨</option>
                            <option value="baozi">è±¹å­å·</option>
                            <option value="shuanglian">åŒè¿æ•°</option>
                            <option value="wanggeng">ç½‘ç»œæ¢—</option>
                            <option value="normal">æ™®é€šå·</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="sortSelect">æ’åº:</label>
                        <select id="sortSelect">
                            <option value="confidence">æŒ‰ç½®ä¿¡åº¦</option>
                            <option value="score">æŒ‰è¯„åˆ†</option>
                            <option value="alphabet">æŒ‰å­—æ¯é¡ºåº</option>
                        </select>
                    </div>
                    
                    <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢è½¦ç‰Œå·...">
                </div>
                
                <div class="plates-grid" id="platesGrid">
                    <div class="loading" id="loadingIndicator" style="display: none;">
                        <div class="spinner"></div>
                        <p>æ­£åœ¨è¯†åˆ«è½¦ç‰Œå·...</p>
                    </div>
                    <div class="no-results" id="noResults" style="display: none;">
                        <p>æš‚æ— è¯†åˆ«ç»“æœ</p>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>&copy; 2025 ä¼˜åŒ–ç‰ˆæœ¬åœ°ç¦»çº¿è½¦ç‰ŒOCRè¯†åˆ«ç³»ç»Ÿ | ä½¿ç”¨Tesseract.js</p>
        </footer>
    </div>

    <!-- å¼•å…¥Tesseract.js -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <script>
        // å›¾åƒé¢„å¤„ç†å‡½æ•°
        function preprocessImage(imageData, options) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            
            // ç»˜åˆ¶åŸå§‹å›¾åƒ
            ctx.putImageData(imageData, 0, 0);
            
            let processedData = imageData;
            
            // ç°åº¦åŒ–
            if (options.grayscale) {
                const imageDataCopy = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageDataCopy.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // ç°åº¦å…¬å¼ï¼š0.299 * R + 0.587 * G + 0.114 * B
                    const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                    
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
                
                processedData = imageDataCopy;
                ctx.putImageData(processedData, 0, 0);
            }
            
            // å¢å¼ºå¯¹æ¯”åº¦
            if (options.contrast) {
                const imageDataCopy = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageDataCopy.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, Math.max(0, (data[i] - 128) * 1.2 + 128)); // R
                    data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * 1.2 + 128)); // G
                    data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * 1.2 + 128)); // B
                }
                
                processedData = imageDataCopy;
                ctx.putImageData(processedData, 0, 0);
            }
            
            // å»å™ª
            if (options.denoise) {
                const imageDataCopy = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageDataCopy.data;
                const newData = new Uint8ClampedArray(data.length);
                
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        
                        // è·å–3x3é‚»åŸŸçš„åƒç´ å€¼
                        const neighbors = [];
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const neighborIdx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                const r = data[neighborIdx];
                                const g = data[neighborIdx + 1];
                                const b = data[neighborIdx + 2];
                                neighbors.push([r, g, b]);
                            }
                        }
                        
                        // è®¡ç®—ä¸­ä½æ•°
                        neighbors.sort((a, b) => a[0] - b[0]);
                        const medianR = neighbors[Math.floor(neighbors.length / 2)][0];
                        neighbors.sort((a, b) => a[1] - b[1]);
                        const medianG = neighbors[Math.floor(neighbors.length / 2)][1];
                        neighbors.sort((a, b) => a[2] - b[2]);
                        const medianB = neighbors[Math.floor(neighbors.length / 2)][2];
                        
                        const newIdx = (y * canvas.width + x) * 4;
                        newData[newIdx] = medianR;
                        newData[newIdx + 1] = medianG;
                        newData[newIdx + 2] = medianB;
                        newData[newIdx + 3] = data[newIdx + 3]; // Alpha
                    }
                }
                
                processedData = new ImageData(newData, canvas.width, canvas.height);
                ctx.putImageData(processedData, 0, 0);
            }
            
            // äºŒå€¼åŒ–
            if (options.threshold) {
                const imageDataCopy = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageDataCopy.data;
                const threshold = options.thresholdValue;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // ç°åº¦è®¡ç®—
                    const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                    
                    const value = gray > threshold ? 255 : 0;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
                
                processedData = imageDataCopy;
                ctx.putImageData(processedData, 0, 0);
            }
            
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // è½¦ç‰Œå·éªŒè¯å’Œæ ¼å¼åŒ–
        function validateAndFormatPlate(plateText) {
            // ç§»é™¤æ‰€æœ‰éä¸­æ–‡ã€å­—æ¯ã€æ•°å­—å­—ç¬¦
            const cleaned = plateText.replace(/[^\u4e00-\u9fa5A-Z0-9]/g, '');
            
            // è½¦ç‰Œå·æ ¼å¼ï¼šçœä»½ç®€ç§°(ä¸­æ–‡) + å­—æ¯ + 5ä½å­—æ¯æ•°å­—
            const plateRegex = /^[\u4e00-\u9fa5][A-Z][A-Z0-9]{5}$/;
            
            if (plateRegex.test(cleaned)) {
                return cleaned;
            }
            
            // å¦‚æœé•¿åº¦ä¸å¤Ÿï¼Œå°è¯•è¡¥é½
            if (cleaned.length >= 2 && cleaned.length < 7) {
                // å‡è®¾å‰ä¸¤ä¸ªå­—ç¬¦æ˜¯çœä»½å’Œå­—æ¯
                const province = cleaned.substring(0, 1);
                const letter = cleaned.substring(1, 2);
                let numbers = cleaned.substring(2);
                
                // å¦‚æœæ•°å­—éƒ¨åˆ†ä¸è¶³5ä½ï¼Œç”¨0è¡¥é½
                if (numbers.length < 5) {
                    numbers = numbers.padEnd(5, '0');
                } else if (numbers.length > 5) {
                    numbers = numbers.substring(0, 5);
                }
                
                const formatted = province + letter + numbers;
                
                if (plateRegex.test(formatted)) {
                    return formatted;
                }
            }
            
            return null;
        }

        // æ¨¡æ‹Ÿè½¦ç‰ŒOCRè¯†åˆ«å‡½æ•°ï¼ˆä½¿ç”¨Tesseract.js + é¢„å¤„ç†ï¼‰
        async function mockOCRRecognition(imageFile, options) {
            return new Promise(async (resolve, reject) => {
                try {
                    // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„URLå¯¹è±¡æ¥è®¿é—®å›¾ç‰‡
                    const imageUrl = URL.createObjectURL(imageFile);
                    
                    // åˆ›å»ºä¸´æ—¶canvasç”¨äºé¢„å¤„ç†
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // åˆ›å»ºå›¾åƒå¯¹è±¡
                    const img = new Image();
                    img.onload = async () => {
                        try {
                            // è®¾ç½®canvaså°ºå¯¸
                            tempCanvas.width = img.width;
                            tempCanvas.height = img.height;
                            
                            // ç»˜åˆ¶åŸå§‹å›¾åƒ
                            tempCtx.drawImage(img, 0, 0);
                            
                            // è·å–åŸå§‹å›¾åƒæ•°æ®
                            let imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                            
                            // åº”ç”¨é¢„å¤„ç†
                            if (options) {
                                imageData = preprocessImage(imageData, options);
                            }
                            
                            // å°†å¤„ç†åçš„å›¾åƒæ•°æ®ç»˜åˆ¶å›canvas
                            tempCtx.putImageData(imageData, 0, 0);
                            
                            // åˆ›å»ºä¸´æ—¶å›¾åƒURLç”¨äºOCR
                            const processedImageUrl = tempCanvas.toDataURL('image/png');
                            
                            // åˆ›å»ºTesseract worker
                            const worker = await Tesseract.createWorker('chi_sim+eng', 1, {
                                logger: m => {
                                    console.log('Tesseract progress:', m);
                                    // è¿™é‡Œå¯ä»¥æ›´æ–°UIæ˜¾ç¤ºè¿›åº¦
                                }
                            });
                            
                            // æ‰§è¡ŒOCRè¯†åˆ«
                            const result = await worker.recognize(processedImageUrl);
                            
                            // é‡Šæ”¾URLå¯¹è±¡
                            URL.revokeObjectURL(imageUrl);
                            
                            // ç®€å•å¤„ç†è¯†åˆ«ç»“æœ
                            let text = result.data.text || '';
                            
                            // æå–å¯èƒ½çš„è½¦ç‰Œå·ï¼ˆç®€å•è§„åˆ™ï¼šçœä»½ç®€ç§°+å­—æ¯+æ•°å­—ï¼‰
                            const plateRegex = /[\u4e00-\u9fa5][A-Z][A-Z0-9]{5}/g;
                            const foundPlates = text.match(plateRegex) || [];
                            
                            // ä¹Ÿå°è¯•æå–ä¸å®Œå…¨åŒ¹é…çš„è½¦ç‰Œå·
                            const incompleteRegex = /[\u4e00-\u9fa5][A-Z][A-Z0-9]{1,5}/g;
                            const incompletePlates = text.match(incompleteRegex) || [];
                            
                            // åˆå¹¶å¹¶å»é‡
                            const allPotentialPlates = [...foundPlates, ...incompletePlates];
                            const uniquePlates = [...new Set(allPotentialPlates)];
                            
                            // éªŒè¯å¹¶æ ¼å¼åŒ–æ¯ä¸ªæ½œåœ¨è½¦ç‰Œå·
                            const validatedPlates = [];
                            for (const plate of uniquePlates) {
                                const formatted = validateAndFormatPlate(plate);
                                if (formatted && !validatedPlates.includes(formatted)) {
                                    validatedPlates.push(formatted);
                                }
                            }
                            
                            // å»é‡å¹¶é™åˆ¶æ•°é‡
                            const finalPlates = validatedPlates.slice(0, 50);
                            
                            // ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®ï¼ˆåŒ…æ‹¬è¯„åˆ†å’Œæ ‡ç­¾ï¼‰
                            const plates = finalPlates.map((plate, index) => {
                                const evaluation = evaluatePlate(plate.substring(1)); // å»æ‰çœä»½ç®€ç§°
                                return {
                                    id: `plate_${index}`,
                                    text: plate,
                                    score: evaluation.score,
                                    tag: evaluation.tag,
                                    note: evaluation.note,
                                    confidence: Math.min(100, 80 + Math.random() * 20), // æ¨¡æ‹Ÿç½®ä¿¡åº¦
                                    position: {
                                        x: 50 + (index % 10) * 70,
                                        y: 50 + Math.floor(index / 10) * 45,
                                        width: 60,
                                        height: 25
                                    }
                                };
                            });
                            
                            // å¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°ï¼Œç”Ÿæˆä¸€äº›ç¤ºä¾‹
                            if (plates.length === 0) {
                                const examplePlates = [
                                    'äº¬A88888', 'æ²ªB66666', 'ç²¤C12345', 'å·D52013', 'æ¹˜E94949'
                                ];
                                plates.push(...examplePlates.map((plate, idx) => {
                                    const evaluation = evaluatePlate(plate.substring(1));
                                    return {
                                        id: `plate_${idx}`,
                                        text: plate,
                                        score: evaluation.score,
                                        tag: evaluation.tag,
                                        note: evaluation.note,
                                        confidence: 90,
                                        position: {
                                            x: 50 + (idx % 5) * 80,
                                            y: 50 + Math.floor(idx / 5) * 45,
                                            width: 60,
                                            height: 25
                                        }
                                    };
                                }));
                            }
                            
                            // é‡Šæ”¾worker
                            await worker.terminate();
                            
                            resolve(plates);
                        } catch (error) {
                            console.error('Preprocessing error:', error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('Image load error:', error);
                        reject(error);
                    };
                    
                    img.src = imageUrl;
                } catch (error) {
                    console.error('OCR Error:', error);
                    reject(error);
                }
            });
        }

        // è¯„ä¼°è½¦ç‰Œå·å¹¶è¿”å›è¯„åˆ†å’Œæ ‡ç­¾
        function evaluatePlate(plateText) {
            const last4 = plateText.substring(1); // è·å–å4ä½
            
            // æ£€æŸ¥ç½‘ç»œæ¢—
            if (/(666|888|520|1314|521|9494|250|110|120|119)/.test(last4)) {
                const match = /(666|888|520|1314|521|9494|250|110|120|119)/.exec(last4)[1];
                return {
                    tag: 'wanggeng',
                    score: 85 + Math.floor(Math.random() * 10),
                    note: getWangGengNote(match)
                };
            }
            
            // æ£€æŸ¥è±¹å­å· (å4ä½ç›¸åŒ)
            if (/^(\d)\1{3}$/.test(last4)) {
                return {
                    tag: 'baozi',
                    score: 95,
                    note: 'å4ä½ç›¸åŒï¼Œå¯“æ„å‰ç¥¥'
                };
            }
            
            // æ£€æŸ¥åŒè¿å· (è‡³å°‘æœ‰ä¸€ç»„åŒè¿)
            if (/(.)\1/.test(last4)) {
                return {
                    tag: 'shuanglian',
                    score: 75,
                    note: 'æœ‰è¿ç»­æ•°å­—ï¼Œæ¯”è¾ƒé¡ºå£'
                };
            }
            
            // æ™®é€šå·
            return {
                tag: 'normal',
                score: 50,
                note: 'æ™®é€šè½¦ç‰Œå·'
            };
        }

        // è·å–ç½‘ç»œæ¢—è¯´æ˜
        function getWangGengNote(match) {
            const explanations = {
                '666': 'é¡ºé¡ºé¡ºï¼Œå¯“æ„é¡ºåˆ©',
                '888': 'å‘å‘å‘ï¼Œå¯“æ„å‘è´¢',
                '520': 'æˆ‘çˆ±ä½ ï¼Œæµªæ¼«æ•°å­—',
                '1314': 'ä¸€ç”Ÿä¸€ä¸–ï¼Œå¯“æ„é•¿ä¹…',
                '521': 'æˆ‘çˆ±ä¸€ï¼Œè°éŸ³"æˆ‘çˆ±æ„"',
                '9494': 'å°±æ˜¯å°±æ˜¯ï¼Œç½‘ç»œç”¨è¯­',
                '250': 'ç½‘ç»œè°ƒä¾ƒç”¨è¯­',
                '110': 'æŠ¥è­¦ç”µè¯',
                '120': 'æ€¥æ•‘ç”µè¯',
                '119': 'ç«è­¦ç”µè¯'
            };
            
            return explanations[match] || 'ç½‘ç»œæµè¡Œæ•°å­—';
        }

        // ä¸»åº”ç”¨ç±»
        class PlateOCRSystem {
            constructor() {
                this.fileInput = document.getElementById('fileInput');
                this.uploadArea = document.getElementById('uploadArea');
                this.realUploadBtn = document.getElementById('realUploadBtn');
                this.previewImg = document.getElementById('previewImg');
                this.imagePreview = document.getElementById('imagePreview');
                this.processBtn = document.getElementById('processBtn');
                this.preprocessBtn = document.getElementById('preprocessBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.statusMessage = document.getElementById('statusMessage');
                this.platesGrid = document.getElementById('platesGrid');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.noResults = document.getElementById('noResults');
                this.filterSelect = document.getElementById('filterSelect');
                this.sortSelect = document.getElementById('sortSelect');
                this.searchInput = document.getElementById('searchInput');
                this.preprocessingOptions = document.getElementById('preprocessingOptions');
                
                // é¢„å¤„ç†é€‰é¡¹
                this.grayscaleCheck = document.getElementById('grayscaleCheck');
                this.contrastCheck = document.getElementById('contrastCheck');
                this.denoiseCheck = document.getElementById('denoiseCheck');
                this.thresholdCheck = document.getElementById('thresholdCheck');
                this.thresholdValue = document.getElementById('thresholdValue');
                this.scaleSelect = document.getElementById('scaleSelect');
                this.rotateSelect = document.getElementById('rotateSelect');
                
                this.plates = [];
                this.selectedPlateId = null;
                
                this.initEventListeners();
            }
            
            initEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
                this.fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.handleFileUpload(file);
                    }
                });
                
                // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸäº‹ä»¶
                this.uploadArea.addEventListener('click', () => {
                    this.fileInput.click();
                });
                
                // æ‹–æ‹½ä¸Šä¼ äº‹ä»¶
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.style.borderColor = '#1890ff';
                    this.uploadArea.style.backgroundColor = '#e6f7ff';
                });
                
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.style.borderColor = '#667eea';
                    this.uploadArea.style.backgroundColor = 'white';
                });
                
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.style.borderColor = '#667eea';
                    this.uploadArea.style.backgroundColor = 'white';
                    
                    if (e.dataTransfer.files.length) {
                        const file = e.dataTransfer.files[0];
                        if (file.type.startsWith('image/')) {
                            this.handleFileUpload(file);
                        }
                    }
                });
                
                // å¤„ç†æŒ‰é’®äº‹ä»¶
                this.processBtn.addEventListener('click', () => this.processImage());
                this.preprocessBtn.addEventListener('click', () => this.togglePreprocessingOptions());
                this.resetBtn.addEventListener('click', () => this.reset());
                
                // ç­›é€‰å’Œæ’åºäº‹ä»¶
                this.filterSelect.addEventListener('change', () => this.renderPlates());
                this.sortSelect.addEventListener('change', () => this.renderPlates());
                this.searchInput.addEventListener('input', () => this.renderPlates());
                
                // é¢„å¤„ç†é€‰é¡¹äº‹ä»¶
                this.thresholdCheck.addEventListener('change', () => {
                    this.thresholdValue.disabled = !this.thresholdCheck.checked;
                });
            }
            
            togglePreprocessingOptions() {
                this.preprocessingOptions.classList.toggle('show');
            }
            
            handleFileUpload(file) {
                if (!file.type.startsWith('image/')) {
                    this.showMessage('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
                    return;
                }
                
                // æ˜¾ç¤ºé¢„è§ˆ
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.previewImg.src = e.target.result;
                    this.imagePreview.style.display = 'block';
                    this.processBtn.disabled = false;
                    this.preprocessBtn.disabled = false;
                    this.showMessage('å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼Œå¯é€‰æ‹©é¢„å¤„ç†é€‰é¡¹åå†è¿›è¡Œè¯†åˆ«', 'success');
                };
                reader.readAsDataURL(file);
            }
            
            showMessage(text, type) {
                this.statusMessage.textContent = text;
                this.statusMessage.className = `status-message status-${type}`;
                this.statusMessage.style.display = 'block';
                
                // 3ç§’åè‡ªåŠ¨éšè—æ¶ˆæ¯
                setTimeout(() => {
                    this.statusMessage.style.display = 'none';
                }, 3000);
            }
            
            async processImage() {
                if (!this.fileInput.files[0]) {
                    this.showMessage('è¯·å…ˆä¸Šä¼ å›¾ç‰‡', 'error');
                    return;
                }
                
                this.processBtn.disabled = true;
                this.loadingIndicator.style.display = 'block';
                this.noResults.style.display = 'none';
                this.showMessage('æ­£åœ¨è¯†åˆ«è½¦ç‰Œå·ï¼Œè¯·ç¨å€™...', 'info');
                
                // è·å–é¢„å¤„ç†é€‰é¡¹
                const options = {
                    grayscale: this.grayscaleCheck.checked,
                    contrast: this.contrastCheck.checked,
                    denoise: this.denoiseCheck.checked,
                    threshold: this.thresholdCheck.checked,
                    thresholdValue: parseInt(this.thresholdValue.value),
                    scale: parseFloat(this.scaleSelect.value),
                    rotate: parseInt(this.rotateSelect.value)
                };
                
                try {
                    // ä½¿ç”¨Tesseract.jsè¿›è¡ŒOCRè¯†åˆ«
                    this.plates = await mockOCRRecognition(this.fileInput.files[0], options);
                    
                    this.showMessage(`è¯†åˆ«å®Œæˆï¼Œå…±æ‰¾åˆ° ${this.plates.length} ä¸ªè½¦ç‰Œå·`, 'success');
                    this.renderPlates();
                } catch (error) {
                    console.error('è¯†åˆ«å¤±è´¥:', error);
                    this.showMessage('è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                } finally {
                    this.loadingIndicator.style.display = 'none';
                    this.processBtn.disabled = false;
                }
            }
            
            renderPlates() {
                // åº”ç”¨ç­›é€‰å’Œæ’åº
                let filteredPlates = [...this.plates];
                
                // åº”ç”¨ç­›é€‰
                const filterValue = this.filterSelect.value;
                if (filterValue) {
                    filteredPlates = filteredPlates.filter(p => p.tag === filterValue);
                }
                
                // åº”ç”¨æœç´¢
                const searchValue = this.searchInput.value.toLowerCase();
                if (searchValue) {
                    filteredPlates = filteredPlates.filter(p => 
                        p.text.toLowerCase().includes(searchValue)
                    );
                }
                
                // åº”ç”¨æ’åº
                const sortValue = this.sortSelect.value;
                if (sortValue === 'confidence') {
                    filteredPlates.sort((a, b) => b.confidence - a.confidence);
                } else if (sortValue === 'score') {
                    filteredPlates.sort((a, b) => b.score - a.score);
                } else if (sortValue === 'alphabet') {
                    filteredPlates.sort((a, b) => a.text.localeCompare(b.text));
                }
                
                // æ¸…ç©ºç°æœ‰å†…å®¹
                this.platesGrid.innerHTML = '';
                
                // æ˜¾ç¤ºç»“æœæˆ–æ— ç»“æœæç¤º
                if (filteredPlates.length === 0 && this.plates.length > 0) {
                    this.noResults.style.display = 'block';
                    this.platesGrid.appendChild(this.noResults);
                } else {
                    this.noResults.style.display = 'none';
                    
                    filteredPlates.forEach(plate => {
                        const plateElement = document.createElement('div');
                        plateElement.className = `plate-item ${this.selectedPlateId === plate.id ? 'selected' : ''}`;
                        plateElement.dataset.id = plate.id;
                        
                        // è·å–æ ‡ç­¾æ–‡æœ¬
                        const tagText = this.getTagText(plate.tag);
                        
                        plateElement.innerHTML = `
                            <div class="plate-number">${plate.text}</div>
                            <div class="plate-score">è¯„åˆ†: ${plate.score}</div>
                            <div class="plate-tag tag-${plate.tag}">${tagText}</div>
                            <div class="confidence-score">ç½®ä¿¡åº¦: ${Math.round(plate.confidence)}%</div>
                            ${plate.note ? `<div class="wanggeng-note">${plate.note}</div>` : ''}
                        `;
                        
                        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        plateElement.addEventListener('click', () => {
                            this.selectPlate(plate);
                        });
                        
                        this.platesGrid.appendChild(plateElement);
                    });
                }
            }
            
            getTagText(tag) {
                switch(tag) {
                    case 'baozi': return 'è±¹å­å·';
                    case 'shuanglian': return 'åŒè¿æ•°';
                    case 'wanggeng': return 'ç½‘ç»œæ¢—';
                    case 'normal': return 'æ™®é€šå·';
                    default: return 'æœªçŸ¥';
                }
            }
            
            selectPlate(plate) {
                this.selectedPlateId = plate.id;
                
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                document.querySelectorAll('.highlight').forEach(el => el.remove());
                
                // åœ¨å›¾ç‰‡ä¸Šæ·»åŠ é«˜äº®æ¡†
                if (plate.position) {
                    const highlight = document.createElement('div');
                    highlight.className = 'highlight';
                    highlight.style.left = `${plate.position.x}px`;
                    highlight.style.top = `${plate.position.y}px`;
                    highlight.style.width = `${plate.position.width}px`;
                    highlight.style.height = `${plate.position.height}px`;
                    
                    this.imagePreview.appendChild(highlight);
                }
                
                // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°é€‰ä¸­çŠ¶æ€
                this.renderPlates();
            }
            
            reset() {
                this.fileInput.value = '';
                this.previewImg.src = '';
                this.imagePreview.style.display = 'none';
                this.processBtn.disabled = true;
                this.preprocessBtn.disabled = true;
                this.plates = [];
                this.selectedPlateId = null;
                
                // æ¸…é™¤æ‰€æœ‰é«˜äº®
                document.querySelectorAll('.highlight').forEach(el => el.remove());
                
                // é‡ç½®ç­›é€‰å™¨
                this.filterSelect.value = '';
                this.sortSelect.value = 'confidence';
                this.searchInput.value = '';
                
                // æ¸…ç©ºç»“æœåŒºåŸŸ
                this.platesGrid.innerHTML = '';
                this.loadingIndicator.style.display = 'none';
                this.noResults.style.display = 'none';
                
                this.statusMessage.style.display = 'none';
                
                // å…³é—­é¢„å¤„ç†é€‰é¡¹
                this.preprocessingOptions.classList.remove('show');
                
                // é‡ç½®é¢„å¤„ç†é€‰é¡¹
                this.grayscaleCheck.checked = false;
                this.contrastCheck.checked = true;
                this.denoiseCheck.checked = true;
                this.thresholdCheck.checked = false;
                this.thresholdValue.disabled = true;
                this.thresholdValue.value = '128';
                this.scaleSelect.value = '1.5';
                this.rotateSelect.value = '0';
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new PlateOCRSystem();
        });
    </script>
</body>
</html>



